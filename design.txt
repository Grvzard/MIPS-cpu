- adder32 overflow flag

truth table of (A[31], B[31], 31st Ci, 31st Co, F[31])
A B Ci F Co
0 0 0  0 0
0 0 1  1 0  (overflow)
0 1 0  1 0
0 1 1  0 1
1 0 0  1 0
1 0 1  0 1
1 1 0  0 1  (overflow)
1 1 1  1 1

tuple (A, B, F) identifiable
overflow <==> Ci ^ Co <==> (~A & ~B & F) | (A & B & ~F)

- flush a stage's result
(to prevent reg-files from being modified by this result)
(pc, 32gpr)
IF: instr <- 0
ID: RegWr <- 0, MemWr <- 0
EX: RegWr <- 0, MemWr <- 0, Overflow <- 0

- slt/sltu, the implementation of less-then comparator
slt:  A < B <==> A - B < 0 <==> Sign & ~Overflow | Overflow & ~Sign <==> Sign ^ Overflow
sltu: A < B -> B + (-B) = (F:0, Cout:1) -> A + (-B) < (F:0, Cout:1) <==> ~Cout

- jumps and branches (one delay slot)
OP     CODE
beq    000
bgez   001
bgezal 010
bgtz   011
blez   100
bltz   101
bltzal 110
bne    111

beq/bne: ~^BranchOp
bgezal/bltzal: Branch & RegWr
jr/jalr: Jump & Rtype
j: Jump & ~Rtype & ~RegWr
jal: Jump & ~Rtype & RegWr

in stages other than ID, Branch means Branch or Jump
